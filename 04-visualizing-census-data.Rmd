# Exploring US Census data with visualization

The core visualization package within the __tidyverse__ suite of packages is __ggplot2__ (Wickham 2016).  Originally developed by RStudio chief scientist Hadley Wickham, ggplot2 is a widely-used visualization framework by R developers, accounting for X downloads per day in XXX.  ggplot2 allows R users to visualize data using a _layered grammar of graphics_ approach, in which plot objects are initialized upon which the R user layers plot elements.  

ggplot2 is an ideal package for visualization of US Census data, especially when obtained in tidy format by the __tidycensus__ package.  It has powerful capacity for basic charts, group-wise comparisons, and advanced chart types such as maps (which will be covered in the next chapter).  

This chapter includes several examples of how R users can visualize data from the US Census Bureau using ggplot2.  Chart types explored in this chapter include basic chart types; faceted, or "small multiples" plots; population pyramids; margin of error plots for ACS data; and advanced visualizations using extensions to ggplot2.  Finally, the chapter introduces the __plotly__ package for interactive visualization, which can be used to convert ggplot2 objects to interactive web graphics.  

## Basic Census visualization with ggplot2

In this example, we will create a visualization that illustrates the percent of commuters that take public transportation to work for the largest metropolitan areas in the United States.  To determine this information, we can use __tidyverse__ tools to sort our data by descending order of a summary variable representing total population and then retaining the 20 largest metropolitan areas by population.  

```{r}

library(tidycensus)
library(tidyverse)

metros <- get_acs(geography = "metropolitan statistical area/micropolitan statistical area", 
        variables = "DP03_0021PE", 
        summary_var = "B01003_001", 
        survey = "acs1") %>%
  filter(min_rank(desc(summary_est)) < 21)


metros
```

(refine this)

ggplot visualizations are initialized with the `ggplot()` function, to which a user commonly supplies a dataset and an `aesthetic`, defined with the `aes()` function.  Within the `aes()` function, a user can specify a series of mappings onto either the data axes or other characteristics of the plot, such as element fill or color.  

After initializing the ggplot object, users can layer plot elements onto the plot object.  Essential to the plot is a `geom`, which specifies one of many chart types available in ggplot2.  For example, `geom_bar()` will create a bar chart, `geom_line()` a line chart, `geom_point()` a point plot, and so forth.  Layers are linked to the ggplot object by using the `+` operator.  

In the basic example below, we can create a dot plot comparing public transportation as commute share for the most populous metropolitan areas in the United States with a minimum of code: 

```{r}
p <- ggplot(metros, aes(x = NAME, y = estimate)) + 
  geom_point()

p
```

As evidenced by the above chart, there are a number of key issues to address.  The x-axis labels are so lengthy that they overlap and are impossible to read; the axis titles are not intuitive; and the data are not sorted, making it difficult to compare similar observations.  

Fortunately, the plot can be made more legible by cleaning up the metropolitan area name, re-ordering the data in descending order, then adding layers to the plot definition.  Additionally, ggplot2 visualization can be used in combination with __magrittr__ piping and in turn tidyverse functions, allowing analysts to string together data manipulation and visualization processes.  

(Consider: step-by-step, or all at once?)

```{r}

p <- metros %>%
  mutate(NAME = str_replace(NAME, "-.*$", "")) %>%
  mutate(NAME = str_replace(NAME, ",.*$", "")) %>%
  ggplot(aes(y = reorder(NAME, estimate), x = estimate)) + 
  geom_point(size = 3, color = "navy") + 
  labs(title = "Percentage of residents who take public transportation to work", 
       subtitle = "2017 1-year ACS estimates, major US metropolitan areas", 
       y = "", 
       x = "ACS estimate (percent)", 
       caption = "Source: ACS Data Profile variable DP03_0021P via the tidycensus R package")
  

p

```

After making the above modifications, the plot is much more legible, and the sorting of metropolitan areas allows for comparisons between proximate metros.

## Visualizing margins of error

As discussed in Chapter 3, handling margins of error appropriately is of significant importance for analysts working with ACS data.  While __tidycensus__ has tools available for working with margins of error in a data wrangling workflow, it is also often useful to visualize those margins of error to illustrate the degree of uncertainty around estimates, especially when making comparisons between those estimates.  

In the above example visualization of public transportation mode share by metropolitan area for the largest metros in the United States, estimates are associated with margins of error; however, these margins of error are relatively small given the large population size of the geographic units represented in the plot.  However, if studying demographic trends for geographies of smaller population size - like counties, Census tracts, or block groups - comparisons can be subject to a considerable degree of uncertainty.  

In the example below, we will compare the median household incomes of counties in the US state of Maine from the 2013-2017 ACS.  Before doing so, it is helpful to understand some basic information about counties in Maine, such as the number of counties and their total population.  We can retrieve this information with tidycensus.  

```{r}
maine <- get_acs(state = "Maine", geography = "county", 
                 variables = c(totalpop = "B01003_001")) %>%
  arrange(desc(estimate))

maine
```

There are sixteen counties in Maine, ranging in population from a maximum of 286,119 to a minimum of 17,156.  In turn, estimates for the counties with smaller population sizes are likely to be subject to a larger margin of error than those with larger baseline populations.  

Comparing median household incomes of these sixteen counties illustrates this point.  We can first obtain this data with tidycensus, then plot the result with a dot plot in a similar fashion to the previous section.  

```{r}
inc <- get_acs(state = "Maine", geography = "county", 
               variables = c(hhincome = "B19013_001")) %>%
  mutate(NAME = str_replace(NAME, " County, Maine", ""))

ggplot(inc, aes(x = estimate, y = reorder(NAME, estimate))) + 
  geom_point(size = 3, color = "darkgreen") + 
  labs(title = "Median household income", 
       subtitle = "Counties in Maine", 
       x = "", 
       y = "ACS estimate") + 
  scale_x_continuous(labels = scales::dollar)
```

The above visualization suggests a ranking of counties from the wealthiest (Cumberland) to the poorest (Aroostook).  In several instances, the estimates of neighboring counties in the ranking is quite close.  Importantly, however, these estimates - represented by dots on the chart - are associated with varying margins of error.  We can explore this by looking directly at the data.  

```{r}
inc %>% arrange(desc(estimate))
```


Specifically, margins of error around the estimated median household incomes vary from a low of $893 (Aroostook County) to a high of $2998 (Sagadahoc County).  In many cases, the margins of error around estimated county household income exceed the differences between counties of neighboring ranks, suggesting uncertainty in the ranks themselves.  

In turn, a dot plot like the one above intended to visualize a ranking of county household incomes in Maine may be misleading.  However, using visualization tools in ggplot2, we can visualize the uncertainty around each estimate, giving chart readers a sense of the uncertainty in the ranking.  This is accomplished with the `geom_errorbarh()` function, which will plot horizontal error bars around each dot that stretch to a given value around each estimate.  In this instance, we will use the `moe` column to determine the lengths of the error bars.  

```{r}
ggplot(inc, aes(x = estimate, y = reorder(NAME, estimate))) + 
  geom_errorbarh(aes(xmin = estimate - moe, xmax = estimate + moe)) + 
  geom_point(size = 3, color = "darkgreen") + 
  labs(title = "Median household income", 
       subtitle = "Counties in Maine", 
       x = "ACS estimate", 
       y = "") + 
  scale_x_continuous(labels = scales::dollar)
```

Adding the horizontal error bars around each point gives us critical information to help us understand how our ranking of Maine counties by median household income.  For example, while the ACS estimate suggests that Aroostook County has the lowest median household income in Maine, the large margin of error around the estimate for Piscataquis County suggests that it too _could_ have the lowest median income in the state.  Additionally, while Androscoggin County has a higher estimated median household income than Hancock and Kennebec Counties, the margin of error plot shows us that this ranking is subject to considerable uncertainty.   

## Exploring age and sex structure with population pyramids

A common method for visualizing the demographic structure of a particular area is the _population pyramid_.  Population pyramids are typically constructed by visualizing population size or proportion on the x-axis; age cohort on the y-axis; and sex is represented categorically with male and female bars mirrored around a central axis.  

We can illustrate this type of visualization using data from the 2010 decennial US Census for the state of Utah.  We first obtain data using the `get_estimates()` function in tidycensus for 2017 population estimates from the Census Bureau's Population Estimates API, with a summary variable representing total population: 

```{r}
library(tidycensus)
library(tidyverse)

utah <- get_estimates(geography = "state", 
                     state = "UT", 
                     product = "characteristics", 
                     breakdown = c("SEX", "AGEGROUP"),  
                     breakdown_labels = TRUE) 

utah

```

The function returns a tidy dataset in which each row represents values for age groups for the state of Utah, characterized by a summary value which represents the total population for Utah, to be used as a normalizing attribute.  However, there are two key issues with this dataset that must be addressed before constructing a population pyramid.  First, three of the rows themselves represent summary values; `P0120001` for total population, `P0120002` for total male population, and `P0120026` for total female population.  Further, some rows represent age bands smaller than five years, meaning that the rows are not directly comparable to each other at the moment.  These issues can be resolved with some data wrangling using tidyverse tools.  

First, we remove the summary rows: 

```{r}
utah_filtered <- filter(utah, str_detect(AGEGROUP, "^Age"), 
                  SEX != "Both sexes") %>%
  mutate(value = ifelse(SEX == "Male", -value, value))

utah_filtered
```

Next, we specify a mapping of age groups


```{r}
ggplot(utah_filtered, aes(x = AGEGROUP, y = value, fill = SEX)) + 
  geom_bar(stat = "identity", width = 1) + 
  theme_minimal(base_family = "Roboto") + 
  scale_y_continuous(labels = function(y) paste0(abs(y / 1000), "k")) + 
  scale_x_discrete(labels = function(x) gsub("Age | years", "", x)) + 
  scale_fill_manual(values = c("darkred", "navy")) + 
  coord_flip() + 
  labs(x = "", 
       y = "2017 Census Bureau population estimate", 
       title = "Population structure in Utah", 
       fill = "", 
       caption = "Data source: US Census Bureau population estimates & tidycensus R package")
```




## Making comparisons with faceted plots

One of the most powerful features of ggplot2 is its ability to generate _faceted plots_, which are also commonly referred to as _small multiples_.  Faceted plots allow for the sub-division of a dataset into groups, which are then plotted side-by-side to facilitate comparisons between those groups.  

```{r}
housing_val <- get_acs(geography = "tract", 
                       variables = "B25077_001", 
                       state = "OR", 
                       county = c("Multnomah", "Clackamas", "Washington"))

housing_val
```

```{r}
housing_val2 <- separate(housing_val, NAME, 
                         into = c("tract", "county", "state"), 
                         sep = ",")

housing_val2
```



```{r}
ggplot(housing_val2, aes(x = estimate)) +
  geom_density(fill = "darkgreen", color = "darkgreen", alpha = 0.5) + 
  facet_wrap(~county)
  
```



## Advanced visualization with ggplot2 extensions



## Interactive visualization with plotly


