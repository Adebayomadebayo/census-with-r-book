# Wrangling Census data with tidyverse tools

One of the most popular frameworks for data analysis in R is the __tidyverse__, a suite of packages designed for integrated data wrangling, visualization, and modeling.  The "tidy" or long-form data returned by default in tidycensus is designed to work well with tidyverse analytic workflows.  This chapter provides an overview of how to use tidyverse tools to gain additional insights about US Census data retrieved with tidycensus.  It concludes with discussion about margins of error (MOEs) in the American Community Survey and how to wrangle and interpret MOEs appropriately.

## Exploring Census data with tidyverse tools

Census data queries using tidycensus, combined with core tidyverse functions, are excellent ways to explore downloaded Census data.  

```{r}
library(tidycensus)

median_age <- get_acs(
  geography = "county",
  variables = "B01002_001"
)

median_age
```

What are the youngest counties in the US?

```{r}
library(tidyverse)

arrange(median_age, estimate)
```

How about the oldest?

```{r}
arrange(median_age, desc(estimate))
```

Filter data by values: 

```{r}
filter(median_age, estimate >= 50)
```

Parsing data: 

```{r}
separate(
  median_age,
  NAME,
  into = c("county", "state"),
  sep = ", "
)
```



## Group-wise Census data analysis

For example, variables in ACS table B19001 represents groups of households whose household incomes fall into a variety of categories: less than $10,000/year, between $10,000/year and $19,999/year, and so forth.  Commonly, these categories will be more granular than needed by an analyst.  As such, an analyst might take the following steps: 1) recode the ACS variables into wider income bands; 2) group the data by the wider income bands; 3) calculate grouped sums to generate new estimates.  

Consider the following example, using household income data for Minnesota counties from the 2012-2016 ACS: 

```{r}
library(tidycensus)
library(tidyverse)


mn1 <- get_acs(
  geography = "county",
  table = "B19001",
  state = "MN"
)

mn1
```

Our data include household income categories for each county in the rows.  However, let's say we only need three income categories for purposes of analysis: below $35,000/year, between $35,000/year and $75,000/year, and $75,000/year and up.  

We first need to do some transformation of our data to recode the variables appropriately.  First, we will remove variable `B19001_001`, which represents the total number of households for each county.  Second, we will modify the appearance of the variable names with string methods using __stringr__, the package in the tidyverse used for string manipulation.  

```{r}
mn2 <- mn1 %>%
  filter(variable != "B19001_001") %>%
  mutate(variable = str_sub(variable, start = -2))

mn2

```

Our data are now ready for group-wise recoding.  To do this, we use the `case_when()` function from the __dplyr__ package (part of the tidyverse) to identify groups of variables that correspond to our desired groupings.  From there, we can group by county and income group, and in turn retrieve group-wise estimates for each county using the `summarize()` function in __dplyr__.  

```{r}
mn3 <- mn2 %>%
  mutate(incgroup = case_when(
    variable %in% c("02", "03", "04", 
                    "05", "06", "07") ~ "below35k", 
    variable %in% c("08", "09", "10", 
                    "11", "12") ~ "bw35kand75k", 
    variable %in% c("13", "14", "15", 
                    "16", "17") ~ "above75k"
  )) %>%
  group_by(GEOID, incgroup) %>%
  summarize(estimate = sum(estimate))

mn3
  
```

Our data now reflect the new estimates by group.  

## Summary variables

Data in Census and ACS tables, as in the example above, are frequently comprised of variables that individually constitute sub-categories such as the numbers of households in different household income bands.  One limitation of the approach above, however, is that the data - and the resulting analysis - return estimated counts, which are difficult to compare across geographies.  For example, Hennepin County in Minnesota is the state's most populous county with X residents; in turn, comparing Hennepin's estimates with those of smaller counties in Minnesota may be inappropriate.  

A solution to this issue might involve __normalizing__ the count data by dividing it by the overall population from which the sub-group is derived. Appropriate denominators for ACS tables are frequently found in the tables themselves as variables.  In ACS table B19001, which covers the number of households by income bands, the variable `B19001_001` represents the total number of households in a given enumeration unit, which we removed from our analysis earlier.  Given that this variable is an appropriate denominator for the other variables in the table, it merits its own column to facilitate the calculation of proportions or percentages.  

In tidycensus, this can be accomplished by supplying a variable ID to the `summary_var` parameter in both the `get_acs()` and `get_decennial()` functions.  Doing so will create two new columns for the decennial Census datasets - `summary_var` and `summary_value`, representing the summary variable ID and the summary variable's value - and three new columns for the ACS datasets, `summary_var`, `summary_est`, and `summary_moe`, which includes the ACS estimate and margin of error for the summary variable.  

With this information in hand, normalizing data is straightforward.  The following example uses the `summary_var` parameter to consider the percentage of the population that is non-Hispanic white, non-Hispanic black, and Hispanic by county in Texas from the 2012-2016 ACS: 

```{r}
race_vars <-
  c(
    White = "B03002_003",
    Black = "B03002_004",
    Native = "B03002_005",
    Asian = "B03002_006",
    HIPI = "B03002_007",
    Hispanic = "B03002_012"
  )

tx_race <- get_acs(
  geography = "county",
  state = "TX",
  variables = race_vars,
  summary_var = "B03002_001"
) %>%
  mutate(pct = 100 * (estimate / summary_est))

```

By using dplyr's `mutate()` function, we calculate a new column, `pct`, representing the percentage of each Census tract's population that corresponds to each racial/ethnic group in 2000.  

## Comparing ACS estimates over time 

```{r}
college_vars <- c("B15002_015",
                  "B15002_016",
                  "B15002_017",
                  "B15002_018",
                  "B15002_032",
                  "B15002_033",
                  "B15002_034",
                  "B15002_035")

college_data <- get_acs(
  geography = "county",
  variables = college_vars,
  state = "CO",
  county = c("Boulder", "Denver", "Broomfield",
             "Adams", "Arapahoe", "Jefferson"),
  summary_var = "B15002_001"
)
```
Use purrr to iterate over multiple years: 

```{r}
years <- c(2009, 2014, 2019)

college_by_year <- map_df(years, ~{
  get_acs(
    geography = "county",
    variables = college_vars,
    state = "CO",
    county = c(
      "Boulder",
      "Denver",
      "Broomfield",
      "Adams",
      "Arapahoe",
      "Jefferson"
    ),
    summary_var = "B15002_001",
    year = .x
  ) %>%
    group_by(NAME) %>%
    summarize(numerator = sum(estimate),
              denominator = first(summary_est)) %>%
    mutate(pct_college = 100 * (numerator / denominator),
           year = .x) 
}) %>%
  select(NAME, year, pct_college) %>%
  arrange(NAME, year)
```

```{r}
college_by_year
```



## Handling margins of error in the American Community Survey with tidycensus


## Using margin of error functions in tidycensus


## Calculating group-wise margins of error





