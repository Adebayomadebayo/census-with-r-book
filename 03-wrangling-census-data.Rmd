# Wrangling Census data with tidyverse tools

```{r setup-ch3, include = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

One of the most popular frameworks for data analysis in R is the **tidyverse**, a suite of packages designed for integrated data wrangling, visualization, and modeling. The "tidy" or long-form data returned by default in tidycensus is designed to work well with tidyverse analytic workflows. This chapter provides an overview of how to use tidyverse tools to gain additional insights about US Census data retrieved with tidycensus. It concludes with discussion about margins of error (MOEs) in the American Community Survey and how to wrangle and interpret MOEs appropriately.

## The tidyverse

[The tidyverse](https://www.tidyverse.org/) is a collection of R packages that are designed to work together in common data wrangling, analysis, and visualization projects. These R packages are maintained by RStudio, many of which are among the most popular R packages worldwide. Some of the key packages you'll use in the tidyverse include:

-   readr, which contains tools for importing and exporting datasets;

-   dplyr, a powerful framework for data wrangling tasks;

-   tidyr, a package for reshaping data;

-   purrr, a comprehensive framework for functional programming and iteration;

-   ggplot2, a data visualization package based on the Grammar of Graphics

The core data structure used in the tidyverse is the *tibble*, which is an R data frame with some small enhancements to improve the user experience. tidycensus returns tibbles by default.

A full treatment of the tidyverse and its functionality is beyond the scope of this book; however, the examples in this chapter will introduce you to several key tidyverse features using US Census Bureau data. For a more general and broader treatment of the tidyverse, I recommend the [*R for Data Science*](https://r4ds.had.co.nz/index.html)text (cite here)

## Exploring Census data with tidyverse tools

Census data queries using tidycensus, combined with core tidyverse functions, are excellent ways to explore downloaded Census data. Chapter 2 covered how to download data from various Census datasets using tidycensus and return the data in a desired format. A common next step in an analytic process will involve data exploration, which is handled by a wide range of tools in the tidyverse.  

To get started, the tidycensus and tidyverse packages are loaded.  "tidyverse" is not specifically a package itself, but rather loads several core packages within the tidyverse.  The package load message gives you more information:

```{r load-tidyverse, message = TRUE}
library(tidycensus)
library(tidyverse)
```
Eight tidyverse packages are loaded: ggplot2, tibble, purrr, dplyr, readr, and tidyr are included along with stringr for string manipulation and forcats for working with factors. These tools collectively can be used for many core Census data analysis tasks.  

For a first example, let's request data on median age from the 2015-2019 ACS with `get_acs()` for all counties in the United States.  This requires specifying `geography = "county"` and leaving state set to `NULL`, the default.  

```{r, median-age}
median_age <- get_acs(
  geography = "county",
  variables = "B01002_001",
  year = 2019
)

median_age
```

The default method for printing data used by the tibble package shows the first 10 rows of the dataset, which in this case prints counties in Alabama.  A first exploratory data analysis question might involve understanding which counties are the _youngest_ and _oldest_ in the United States as measured by median age.  This task can be accomplished with the `arrange()` function found in the dplyr package.  `arrange()` sorts a dataset by values in one or more columns and returns the sorted result.  To view the dataset in ascending order of a given column, supply the data object and a column name to the `arrange()` function.

```{r}
arrange(median_age, estimate)
```

How about the oldest?

```{r}
arrange(median_age, desc(estimate))
```

Filter data by values:

```{r}
filter(median_age, estimate >= 50)
```

Parsing data:

```{r}
separate(
  median_age,
  NAME,
  into = c("county", "state"),
  sep = ", "
)
```

## Summary variables

Data in Census and ACS tables, as in the example above, are frequently comprised of variables that individually constitute sub-categories such as the numbers of households in different household income bands. One limitation of the approach above, however, is that the data - and the resulting analysis - return estimated counts, which are difficult to compare across geographies. For example, Hennepin County in Minnesota is the state's most populous county with X residents; in turn, comparing Hennepin's estimates with those of smaller counties in Minnesota may be inappropriate.

A solution to this issue might involve **normalizing** the count data by dividing it by the overall population from which the sub-group is derived. Appropriate denominators for ACS tables are frequently found in the tables themselves as variables. In ACS table B19001, which covers the number of households by income bands, the variable `B19001_001` represents the total number of households in a given enumeration unit, which we removed from our analysis earlier. Given that this variable is an appropriate denominator for the other variables in the table, it merits its own column to facilitate the calculation of proportions or percentages.

In tidycensus, this can be accomplished by supplying a variable ID to the `summary_var` parameter in both the `get_acs()` and `get_decennial()` functions. Doing so will create two new columns for the decennial Census datasets - `summary_var` and `summary_value`, representing the summary variable ID and the summary variable's value - and three new columns for the ACS datasets, `summary_var`, `summary_est`, and `summary_moe`, which includes the ACS estimate and margin of error for the summary variable.

With this information in hand, normalizing data is straightforward. The following example uses the `summary_var` parameter to consider the percentage of the population that is non-Hispanic white, non-Hispanic black, and Hispanic by county in Texas from the 2012-2016 ACS:

```{r}
race_vars <- c(
  White = "B03002_003",
  Black = "B03002_004",
  Native = "B03002_005",
  Asian = "B03002_006",
  HIPI = "B03002_007",
  Hispanic = "B03002_012"
)

az_race <- get_acs(
  geography = "county",
  state = "AZ",
  variables = race_vars,
  summary_var = "B03002_001"
) 

az_race

```

By using dplyr's `mutate()` function, we calculate a new column, `percent`, representing the percentage of each Census tract's population that corresponds to each racial/ethnic group in 2000.

```{r}
az_race_percent <- az_race %>%
  mutate(percent = 100 * (estimate / summary_est)) %>%
  select(NAME, variable, percent)

az_race_percent
```

## Group-wise Census data analysis

## What is the largest group by county?

```{r largest-group}
largest_group <- az_race_percent %>%
  group_by(NAME) %>%
  filter(percent == max(percent))
```

------------------------------------------------------------------------

```{r view-largest-group}
largest_group
```

------------------------------------------------------------------------

## What are the median percentages by group?

```{r median-by-group}
az_race_percent %>%
  group_by(variable) %>%
  summarize(median_pct = median(percent))
```

### Tabulating new groups

For example, variables in ACS table B19001 represents groups of households whose household incomes fall into a variety of categories: less than \$10,000/year, between \$10,000/year and \$19,999/year, and so forth. Commonly, these categories will be more granular than needed by an analyst. As such, an analyst might take the following steps: 1) recode the ACS variables into wider income bands; 2) group the data by the wider income bands; 3) calculate grouped sums to generate new estimates.

Consider the following example, using household income data for Minnesota counties from the 2012-2016 ACS:

```{r}
library(tidycensus)
library(tidyverse)


mn1 <- get_acs(
  geography = "county",
  table = "B19001",
  state = "MN"
)

mn1
```

Our data include household income categories for each county in the rows. However, let's say we only need three income categories for purposes of analysis: below \$35,000/year, between \$35,000/year and \$75,000/year, and \$75,000/year and up.

We first need to do some transformation of our data to recode the variables appropriately. First, we will remove variable `B19001_001`, which represents the total number of households for each county. Second, we will modify the appearance of the variable names with string methods using **stringr**, the package in the tidyverse used for string manipulation.

```{r}
mn2 <- mn1 %>%
  filter(variable != "B19001_001") %>%
  mutate(variable = str_sub(variable, start = -2))

mn2

```

Our data are now ready for group-wise recoding. To do this, we use the `case_when()` function from the **dplyr** package (part of the tidyverse) to identify groups of variables that correspond to our desired groupings. From there, we can group by county and income group, and in turn retrieve group-wise estimates for each county using the `summarize()` function in **dplyr**.

```{r}
mn3 <- mn2 %>%
  mutate(incgroup = case_when(
    variable %in% c("02", "03", "04", 
                    "05", "06", "07") ~ "below35k", 
    variable %in% c("08", "09", "10", 
                    "11", "12") ~ "bw35kand75k", 
    variable %in% c("13", "14", "15", 
                    "16", "17") ~ "above75k"
  )) %>%
  group_by(GEOID, incgroup) %>%
  summarize(estimate = sum(estimate))

mn3
  
```

Our data now reflect the new estimates by group.

## Comparing ACS estimates over time

```{r}
college_vars <- c("B15002_015",
                  "B15002_016",
                  "B15002_017",
                  "B15002_018",
                  "B15002_032",
                  "B15002_033",
                  "B15002_034",
                  "B15002_035")

college_data <- get_acs(
  geography = "county",
  variables = college_vars,
  state = "CO",
  county = c("Boulder", "Denver", "Broomfield",
             "Adams", "Arapahoe", "Jefferson"),
  summary_var = "B15002_001"
)
```

Use purrr to iterate over multiple years:

```{r}
years <- c(2009, 2014, 2019)

college_by_year <- map_df(years, ~{
  get_acs(
    geography = "county",
    variables = college_vars,
    state = "CO",
    county = c(
      "Boulder",
      "Denver",
      "Broomfield",
      "Adams",
      "Arapahoe",
      "Jefferson"
    ),
    summary_var = "B15002_001",
    year = .x
  ) %>%
    group_by(NAME) %>%
    summarize(numerator = sum(estimate),
              denominator = first(summary_est)) %>%
    mutate(pct_college = 100 * (numerator / denominator),
           year = .x) 
}) %>%
  select(NAME, year, pct_college) %>%
  arrange(NAME, year)
```

```{r}
college_by_year
```

## Handling margins of error in the American Community Survey with tidycensus

## Margins of error in the ACS

-   As the American Community Survey is a *survey*, its estimates are subject to a *margin of error*, or MOE

-   By default, MOEs are returned at a 90 percent confidence level; e.g., "we are 90 percent sure that the true value falls within a range defined by the estimate plus or minus the margin of error"

------------------------------------------------------------------------

## Margins of error in tidycensus

-   tidycensus always returns the margin of error for ACS estimates when applicable.

-   By default, margins of error are contained in the `moe` column; in wide-form data, MOEs are found in columns that end with `M`

-   The `moe_level` parameter controls the confidence level of the MOE; choose `90` (the default), `95`, or `99`

------------------------------------------------------------------------

```{r}
library(tidycensus)
library(tidyverse)

vars <- paste0("B01001_0", c(20:25, 44:49))

salt_lake <- get_acs(
  geography = "tract",
  variables = vars,
  state = "Utah",
  county = "Salt Lake",
  year = 2019
)

example_tract <- salt_lake %>%
  filter(GEOID == "49035100100")

example_tract %>% select(-NAME)
```

## Margin of error functions in tidycensus

-   tidycensus includes helper functions for calculating derives margins of error based on Census-supplied formulas. These functions include `moe_sum()`, `moe_product()`, `moe_ratio()`, and `moe_prop()`

Example:

```{r moe-prop}
moe_prop(25, 100, 5, 3)
```

------------------------------------------------------------------------

## Calculating group-wise margins of error

```{r summarize-moe}
salt_lake_grouped <- salt_lake %>%
  mutate(sex = if_else(str_sub(variable, start = -2) < "26",
                       "Male", 
                       "Female")) %>%
  group_by(GEOID, sex) %>%
  summarize(sum_est = sum(estimate), 
            sum_moe = moe_sum(moe, estimate))

```

------------------------------------------------------------------------

```{r view-summarize-moe}
salt_lake_grouped
```

------------------------------------------------------------------------

## Exercises

-   The ACS Data Profile includes a number of pre-computed percentages which can reduce your data wrangling time. The variable in the 2015-2019 ACS for "percent of the population age 25 and up with a bachelor's degree" is `DP02_0068P`. For a state of your choosing, use this variable to determine:

    -   The county with the highest percentage in the state;

    -   The county with the lowest percentage in the state;

    -   The median value for counties in your chosen state
