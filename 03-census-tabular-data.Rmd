# Wrangling Census data with tidyverse tools

Given the widespread use of US Census data in data analytic and data science projects, the R community has developed a number of packages to allow for access to and exploration of these datasets.  These packages commonly grant access, through R, to the US Census Bureau's application programming interfaces, or APIs.  This chapter focuses on one such package, __tidycensus__, which wraps the decennial US Census and American Community Survey APIs and returns data from the APIs as data frames designed for use with the tidyverse.  The chapter commences with an overview of the R packages available for US Census Bureau data access, then transitions to a focus on how to use tidycensus to work with US Census Bureau data.  Finally, the chapter includes a brief introduction to other packages for Census data analysis and visualization in R, with a focus on the acs, censusapi, and choroplethr packages.  

## Group-wise Census data analysis

The tidy format returned by default by tidycensus is designed to facilitate group-wise data analysis.  For example, variables in ACS table B19001 represents groups of households whose household incomes fall into a variety of categories: less than $10,000/year, between $10,000/year and $19,999/year, and so forth.  Commonly, these categories will be more granular than needed by an analyst.  As such, an analyst might take the following steps: 1) recode the ACS variables into wider income bands; 2) group the data by the wider income bands; 3) calculate grouped sums to generate new estimates.  

Consider the following example, using household income data for Minnesota counties from the 2012-2016 ACS: 

```{r}
mn1 <- get_acs(geography = "county", table = "B19001", 
               state = "MN")

mn1
```

Our data include household income categories for each county in the rows.  However, let's say we only need three income categories for purposes of analysis: below $35,000/year, between $35,000/year and $75,000/year, and $75,000/year and up.  

We first need to do some transformation of our data to recode the variables appropriately.  First, we will remove variable `B19001_001`, which represents the total number of households for each county.  Second, we will modify the appearance of the variable names with string methods using __stringr__, the package in the tidyverse used for string manipulation.  

```{r}
mn2 <- mn1 %>%
  filter(variable != "B19001_001") %>%
  mutate(variable = str_sub(variable, start = -2))

mn2

```

Our data are now ready for group-wise recoding.  To do this, we use the `case_when()` function from the __dplyr__ package (part of the tidyverse) to identify groups of variables that correspond to our desired groupings.  From there, we can group by county and income group, and in turn retrieve group-wise estimates for each county using the `summarize()` function in __dplyr__.  

```{r}
mn3 <- mn2 %>%
  mutate(incgroup = case_when(
    variable %in% c("02", "03", "04", 
                    "05", "06", "07") ~ "below35k", 
    variable %in% c("08", "09", "10", 
                    "11", "12") ~ "bw35kand75k", 
    variable %in% c("13", "14", "15", 
                    "16", "17") ~ "above75k"
  )) %>%
  group_by(GEOID, incgroup) %>%
  summarize(estimate = sum(estimate))

mn3
  
```

Our data now reflect the new estimates by group.  

## Summary variables

Data in Census and ACS tables, as in the example above, are frequently comprised of variables that individually constitute sub-categories such as the numbers of households in different household income bands.  One limitation of the approach above, however, is that the data - and the resulting analysis - return estimated counts, which are difficult to compare across geographies.  For example, Hennepin County in Minnesota is the state's most populous county with X residents; in turn, comparing Hennepin's estimates with those of smaller counties in Minnesota may be inappropriate.  

A solution to this issue might involve __normalizing__ the count data by dividing it by the overall population from which the sub-group is derived. Appropriate denominators for ACS tables are frequently found in the tables themselves as variables.  In ACS table B19001, which covers the number of households by income bands, the variable `B19001_001` represents the total number of households in a given enumeration unit, which we removed from our analysis earlier.  Given that this variable is an appropriate denominator for the other variables in the table, it merits its own column to facilitate the calculation of proportions or percentages.  

In tidycensus, this can be accomplished by supplying a variable ID to the `summary_var` parameter in both the `get_acs()` and `get_decennial()` functions.  Doing so will create two new columns for the decennial Census datasets - `summary_var` and `summary_value`, representing the summary variable ID and the summary variable's value - and three new columns for the ACS datasets, `summary_var`, `summary_est`, and `summary_moe`, which includes the ACS estimate and margin of error for the summary variable.  

With this information in hand, normalizing data is straightforward.  The following example uses the `summary_var` parameter to consider the percentage of the population that is non-Hispanic white, non-Hispanic black, and Hispanic by Census tract in Multnomah County, Oregon for the 2000 Census: 

```{r}
race <- get_decennial(geography = "tract", 
                      variables = c(), 
                      summary_var = "", 
                      state = "OR", 
                      county = "Multnomah", 
                      year = 2000) %>%
  mutate(pct = 100 * (value / summary_value))

race
```

By using dplyr's `mutate()` function, we calculate a new column, `pct`, representing the percentage of each Census tract's population that corresponds to each racial/ethnic group in 2000.  

## Handling margins of error in the American Community Survey with tidycensus




## Other Census data packages in R

With over 73,000 downloads from the RStudio CRAN mirror as of October 2017, the __acs__ package (Haber Glenn 2017) is one of the most widely-used tools for Census data access in R.  The acs package allows for access to both decennial Census and American Community Survey data, and includes a suite of tools to manage data downloads and calculate margins of error.  The __choroplethr__ package (Lamstein and Johnson 2017) wraps acs and __ggplot2__ to allow R users to rapidly create maps using Census and ACS data, and also provides access to the underlying data as well.  More recently, the __censusapi__ package (Recht 2017) helps R users access any of the US Census Bureau's data APIs.  While the censusapi package requires more knowledge of the underlying structure of the API to work, its breadth is unmatched among Census API packages in R. 

{give examples of each in this section}