# Working with Census data outside the United States

```{r setup-ch12, include = FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
library(idbr)
library(tidyverse)
library(cancensus)

source("R/book-functions.R")
```

Although the methods presented in this book are generalizable, the examples given in the book to this point have focused on the United States. Readers of this book are most certainly not limited to the United States in their projects, and will be interested in how to apply the methods presented to examples around the world. International Census & demographic data is the focus of this chapter. The first section focuses on *global demographic indicators* for between-country comparisons and gives an overview of the [idbr R package](https://github.com/walkerke/idbr) for accessing these indicators through the [US Census Bureau's International Data Base](https://www.census.gov/programs-surveys/international-programs/about/idb.html). The sections that follow cover country-specific packages from around the world that deliver Census data to R users in similar ways to the US-focused packages covered earlier in this book. Examples from Canada, Mexico, Brazil, and Kenya illustrate how to apply the methods readers have learned in this book to Census data analyses in other parts of the world.

## The International Data Base and the idbr R package

The US Census Bureau's International Database (IDB) is a repository of dozens of demographic indicators for over 200 countries around the world. The IDB includes both historical information by year for most countries as well as population projections to 2100. In-place demographic characteristics are derived from a wide range of international Censuses and surveys, and future projections are estimated with the cohort-component method.

The Census Bureau makes these datasets available to researchers [through an interactive data tool](https://www.census.gov/data-tools/demo/idb/#/country?YR_ANIM=2021) and also through its API, allowing for programmatic data access. The idbr R package, first released in 2016 and updated to version 1.0 in 2021, uses a simple R interface to help users gain access to and analyze data from the IDB.

To get started with idbr, users can install the package from CRAN and set their Census API keys with the `idb_api_key()` function. If a user's Census API key is already installed using tidycensus, idbr will pick it up making this step unnecessary.

```{r idb-api-key, eval = FALSE}
library(idbr)
# Unnecessary if API key is installed with tidycensus
idb_api_key("YOUR KEY GOES HERE")

```

The core function implemented in idbr is `get_idb()`, which can access all datasets available in the IDB. There are two main datasets available: the 1-year-of-age population dataset, which allows for population data by country to be downloaded broken down by age and sex; and the 5-year-of-age dataset, which gives access to population by 5-year age bands but also many other fertility, mortality, and migration indicators that are not organized by age bands.

A basic IDB query uses a country, specified as either an ISO-2 code or a country name in English, a vector of one or more variables, and a vector of one or more years. For example, we can fetch historical and projected population for Nigeria from 1990 to 2100, and quickly visualize it using ggplot2:

```{r nigeria-pop}
nigeria_pop <- get_idb(
  country = "Nigeria",
  variables = "pop",
  year = 1990:2100
)

nigeria_pop

```

```{r plot-nigeria-pop}
library(tidyverse)

ggplot(nigeria_pop, aes(x = year, y = pop)) + 
  geom_line(color = "darkgreen") + 
  theme_minimal() + 
  scale_y_continuous(labels = scales::label_number_si()) + 
  labs(title = "Population of Nigeria",
       subtitle = "1990 to 2100 (projected)",
       x = "Year",
       y = "Population at midyear")
```

idbr includes functionality to help users look up variable codes for use in their function calls. The function `idb_variables()` returns a data frame with all variables available in the IDB, along with an informative label; the `idb_concepts()` function prints out a list of *concepts* that can be supplied to the `concept` parameter and will return a group of variables that belong to the same concept (e.g. mortality rates, components of population growth).

For worldwide analyses, users can specify the argument `country = "all"` to return all available countries in the IDB. In concert with tidyverse tools, this makes global comparative analyses straightforward. In the example below, we get data on life expectancy at birth for all countries in 2021, then view the top 10 and bottom 10 countries.

```{r world-lex}

world_lex <- get_idb(
  country = "all",
  variables = "e0",
  year = 2021
)

world_lex %>% slice_max(e0, n = 10)
```

```{r world-lex-min}
world_lex %>% slice_min(e0, n = 10)
```

### Visualizing IDB data

idbr aims to return data from the IDB in a structure suitable for creative data visualizations. This includes population pyramids (like those introduced in Chapter 4) and world maps.

As mentioned earlier in this chapter, `get_idb()` can retrieve population data by age and sex in one-year age bands if the `age` or `sex` arguments are supplied but `variables` is left blank. An illustration of this is found in the example below, where `get_idb()` is used to get 1-year-of-age population data for 2021 in Japan, broken down by sex.

```{r japan-pop-data}

japan_data <- get_idb(
  country = "Japan",
  year = 2021,
  age = 0:100,
  sex = c("male", "female")
) 

japan_data
```

Following the example illustrated in Chapter 4, a population pyramid can be created by changing data values for one sex to negative, then plotting the data as back-to-back horizontal bar charts.

```{r japan-pyramid}

japan_data %>%
  mutate(pop = ifelse(sex == "Male", pop * -1, pop)) %>%
  ggplot(aes(x = pop, y = as.factor(age), fill = sex)) + 
  geom_col(width = 1) + 
  theme_minimal(base_size = 12) + 
  scale_x_continuous(labels = function(x) paste0(abs(x / 1000000), "m")) + 
  scale_y_discrete(breaks = scales::pretty_breaks(n = 10)) + 
  scale_fill_manual(values = c("darkred", "navy")) + 
  labs(title = "Population structure of Japan in 2021",
       x = "Population",
       y = "Age",
       fill = "")
```

The aging structure of Japan's population is notable, especially the number of female centenarians (women aged 100 and up) that stand out on the chart, a number that is likely to grow in the years ahead.

`get_idb()` also includes a `geometry` parameter to help users make world maps of demographic indicators. By setting `geometry = TRUE`, `get_idb()` returns a simple features object with a `geometry` column attached to the demographic data. Here, we fetch data on total fertility rate by country in 2021.

```{r world-map-data}

library(idbr)
library(tidyverse)

fertility_data <- get_idb(
  country = "all",
  year = 2021,
  variables = "tfr",
  geometry = TRUE,
)

fertility_data
```

There are a couple points of note with respect to the data returned. The dataset leaves out a number of small countries that would not appear on a zoomed-out world map. To ensure that they are retained, use the argument `resolution = "high"` for a higher-resolution dataset (which you may also want for regional mapping). There are also rows returned as `NA` in the dataset; this is to fill in areas that should appear on the map (like Antarctica) but do not have data in the IDB.

The data returned can be mapped with `geom_sf()` from ggplot2 or any other mapping tool introduced in this book. Specifying a suitable map projection with `coord_sf()` for the whole world - like the Robinson projection used below - is recommended.

```{r}

ggplot(fertility_data, aes(fill = tfr)) + 
  theme_bw() + 
  geom_sf() + 
  coord_sf(crs = 'ESRI:54030') + 
  scale_fill_viridis_c() + 
  labs(fill = "Total fertility\nrate (2021)")

```

### Interactive and animated visualization of global demographic data

In Chapter 6, readers learned how to create interactive maps of US Census data with the tmap and leaflet packages. While the same methods *can* be applied to the global data returned by `get_idb()`, the Mercator projection used by the Leaflet library is not ideal for world maps as it inflates the area of countries near the poles relative to countries near the Equator. In turn, it is preferable to turn to other interactive charting libraries such as plotly, discussed in Chapter 4.

Like plotly, the [ggiraph](https://davidgohel.github.io/ggiraph/index.html) package helps users create interactive visualizations from their ggplot2 plots. ggiraph includes `*_interactive()` versions of ggplot2 geoms with package-specific aesthetics to allow for interactive visualization.

To get started, let's return to our global fertility data and create a new column that will store information we want to include in our tooltip that appears when a viewer hovers over a country.

```{r}
fertility_data$tooltip <- paste0(fertility_data$name,
                                 ": ",
                                 round(fertility_data$tfr, 2))
```

We now set up the visualization. Note that instead of using `geom_sf()`, we use ggiraph's `geom_sf_interactive()`, which includes some new aesthetics. We map our new `tooltip` column to the `tooltip` aesthetic, which will generate a hover tooltip, and we map the `code` column to the `data_id` aesthetic, which will change the country's color when hovered over. The `girafe()` function then renders the interactive graphic; we can specify that we want map zooming with `girafe_options()`.

```{r interactive-world-map}
library(ggiraph)

fertility_map <- ggplot(fertility_data, aes(fill = tfr)) + 
  theme_bw() + 
  geom_sf_interactive(aes(tooltip = tooltip, data_id = code), size = 0.1) + 
  coord_sf(crs = 'ESRI:54030') + 
  scale_fill_viridis_c() + 
  labs(fill = "Total fertility\nrate (2021)")

girafe(ggobj = fertility_map) %>%
  girafe_options(opts_zoom(max = 10))
```

The time-series data availability in the IDB also works well for creating animated time-series graphics with help from the [gganimate package](https://gganimate.com/). gganimate extends ggplot2 to animate sequences of plots using intuitive syntax to ggplot2 users. Earlier in this chapter, we learned how to create a population pyramid from IDB data for a single year (2021). If data are requested instead for multiple years, gganimate can be used to transition from year to year in an animated population pyramid, showing how the population structure of a country has evolved (and is projected to evolve) over time.

```{r animated_pyramid, eval = FALSE}
library(idbr)
library(tidyverse)
library(gganimate)

mx_pyramid_data <- get_idb(
  country = "Mexico",
  sex = c("male", "female"),
  age = 0:100,
  year = 1990:2050
) %>%
  mutate(pop = ifelse(sex == "Male", pop * -1, pop))

mx_animation <- ggplot(mx_pyramid_data, aes(x = pop, y = as.factor(age), fill = sex)) + 
  geom_col(width = 1) + 
  theme_minimal(base_size = 16) + 
  scale_x_continuous(labels = function(x) paste0(abs(x / 1000000), "m")) + 
  scale_y_discrete(breaks = scales::pretty_breaks(n = 10)) + 
  scale_fill_manual(values = c("darkred", "darkgreen")) + 
  transition_states(year) + 
  labs(title = "Population structure of Mexico in {closest_state}",
       x = "Population",
       y = "Age",
       fill = "")

animate(mx_animation, height = 500, width = 800)

```

```{r, echo = FALSE, out.width="100%"}
knitr::include_graphics("img/mexico_animation.gif")
```

The animation illustrates the aging of Mexico's population, both observed and projected, during the specified time period.

## Country-specific Census data packages

Analysts around the world need access to high-quality tabular and spatial demographic data to make decisions much like the data that are available from the US Census Bureau. While Censuses are conducted by countries around the world, few countries expose their data by API in the way the US Census Bureau does. Nonetheless, there are a number of R packages that help analysts acquire and work with country-specific Census data. This section of the book covers a sampling of those packages, with examples given from Canada, Mexico, Kenya, and Brazil. These examples will illustrate how to apply many of the techniques introduced in this book to a variety of non-US examples.

### Canada: cancensus

<img src="https://raw.githubusercontent.com/mountainMath/cancensus/master/images/cancensus-sticker.png" width="20%"/>

[The cancensus R package](https://mountainmath.github.io/cancensus/index.html) [@vonbergmann2021] grants comprehensive access to Canadian Census data through the [CensusMapper APIs](https://censusmapper.ca/). While Statistics Canada, the Canadian agency that distributes Canadian demographic data, does not maintain these APIs, package author Jens von Bergmann's CensusMapper product makes Canadian data accessible via a web interface and data API. Working with cancensus will feel familiar to tidycensus users, as cancensus integrates well within the tidyverse and includes an option to return feature geometry along with demographic data for a wide range of Canadian geographies.

To get started with cancensus, obtain an API key from the CensusMapper website and store it in your `.Renviron` file as discussed in Section \@ref(other-census-and-government-data-resources). Supplying this key to the `cancensus.api_key` option will allow the key to be picked up automatically by cancensus functions.

The `list_census_vectors()` function operates in a similar way to `load_variables()` in tidycensus. Specify a dataset to generate a browsable data frame of variable IDs which can be used to query data from the CensusMapper API.

```{r cancensus-1}
library(cancensus)
library(tidyverse)
options(cancensus.api_key = Sys.getenv("CANCENSUS_API_KEY"))

var_list <- list_census_vectors("CA16")
```

```{r show-canada-vars, echo = FALSE}
style_data(var_list, n_rows = 5, caption = "var_list")
```

The data can be browsed with the `View()` function in RStudio much like it is recommended to do with tidycensus in Section \@ref(searching-for-variables-in-tidycensus). Two companion functions, `list_census_regions()` and `list_census_datasets()`, should also be used to identify region codes and dataset codes for which you'd like to request data.

Once determined, the appropriate codes can be passed as arguments to various parameters in the `get_census()` function, the main data access function used in cancensus. The example below fetches data on English speakers by Census tract in the Montreal area in this way.

```{r montreal-english, eval = FALSE}
montreal_english <- get_census(
  dataset = "CA16",
  regions = list(CMA = "24462"),
  vectors = "v_CA16_1364",
  level = "CT",
  geo_format = "sf",
  labels = "short"
) 
```

The example above constructs the query to the CensusMapper API using the following arguments:

-   `dataset = "CA16"` requests data from the 2016 Canadian Census;

-   `regions = list(CMA = "24462")` gets data for the Montreal metropolitan area by using a named list, matching the region type `CMA` with the specific ID for the Montreal area;

-   `vectors = "v_CA16_1364"` fetches data for the specific Census vector that represents English language speaking, as identified using `list_census_vectors()`;

-   `level = "CT"` gets data at the Census tract level;

-   `geo_format = "sf"` instructs `get_census()` to return simple feature geometry for Census tracts along with the Census data;

-   `labels = "short"` returns simpler labels in the output dataset.

Once queried, our data appear as follows:

```{r style_data_cancensus_english}
style_data(montreal_english, 6, "montreal_english")
```

By default, cancensus returns a number of contextual variables along with the requested Census vector; total population, total households, total dwellings, and area can be used for normalization automatically. This information can be used to normalize data on English speakers by calculating a new column with `mutate()` named `pct_english`; familiar mapping tools from Chapter \@ref(mapping-census-data-with-r) are then used to visualize the data.

```{r map-montreal-english, eval = FALSE}
library(tmap)
tmap_mode("view")

montreal_pct <- montreal_english %>%
  mutate(pct_english = 100 * (v_CA16_1364 / Population))

tm_shape(montreal_pct) + 
  tm_polygons(
    col = "pct_english", 
    alpha = 0.5, 
    palette = "viridis",
    style = "jenks", 
    n = 7, 
    title = "Percent speaking<br/>English at home"
  )
```

```{r show-montreal-english, echo = FALSE}
knitr::include_url("img/leaflet/montreal_english.html", height = "500px")
```

Exploring the data interactively reveals distinctive patterns of English language speaking in Montreal. While English is the most common language spoken at home in some central Census tracts and the southwestern portion of the Island of Montreal, percentages are much lower in suburban areas and the outer portions of the metropolitan region.

### Mexico: mxmaps/inegiR

Mexico's national statistics office, the [Instituto Nacional de Estadística y Geografía (INEGI)](https://www.inegi.org.mx/), offers an API for access to many of its datasets. Used together, the [mxmaps](https://www.diegovalle.net/mxmaps/) [@vallejones2021] and [inegiR](https://github.com/Eflores89/inegiR) [@flores2021] R packages allow for geographic analysis and visualization of Mexican Census data obtained from INEGI.

Like other APIs introduced in this book, the INEGI API requires an API token. [This token can be requested from the INEGI website](http://www3.inegi.org.mx//sistemas/api/indicadores/v1/tokenVerify.aspx). Once acquired, it can be used by both mxmaps and inegiR to request data; I'm saving my key as the environment variable `INEGI_API_KEY`.

The mxmaps package is based on the choroplethr R package [@lamstein2020], which offers a convenient interface for visualizing data from the US ACS. mxmaps wraps inegiR's data access functions in the `choropleth_inegi()` function, which can request data for [indicators from INEGI's data bank](https://en.www.inegi.org.mx/app/indicadores/) and visualize them. The map below shows the percentage of residents

```{r mxmaps}
# remotes::install_github("diegovalle/mxmaps")
library(mxmaps)
token_inegi <- Sys.getenv("INEGI_API_KEY")

state_regions <- df_mxstate_2020$region
choropleth_inegi(token_inegi, state_regions, 
                 indicator = "3104003001",
                 legend = "%",
                 title = "Percentage born outside\nstate of residence") + 
  theme_void(base_size = 18)
```

```{r inegir}
library(inegiR)
token_inegi <- Sys.getenv("INEGI_API_KEY")
state_regions <- mxmaps::df_mxstate_2020$region

pct_migrants <- map_df(state_regions, ~{
  inegi_series(series_id = "3104003001", 
               token = token_inegi, 
               geography = .x,
               database = "BISE") %>%
    mutate(state_code = .x)
})
  
```

```{r show-inegir}
head(pct_migrants)
```

------------------------------------------------------------------------

## Brazil: geobr

<img src="https://raw.githubusercontent.com/ipeaGIT/geobr/master/r-package/man/figures/geobr_logo_b.png" width="20%"/>

The geobr [@pereira2021] package from [IPEA](https://www.ipea.gov.br/portal/) helps you load spatial datasets for many Brazilian geographies, including Census boundaries. These datasets are generously hosted by IPEA and downloaded into a user's R session when the corresponding function is called. The `code_tract` parameter can accept a 7-digit municipality code; below, the code for Rio de Janeiro is used. Municipality codes can be looked up with the corresponding `read_municipality()` function.

```{r geobr, results = "hide"}
library(geobr)

rj_tracts <- read_census_tract(code_tract = 3304557)
```

By default, geobr retrieves a Census tract dataset with simplified geometries that is appropriate for small-scale demographic visualization but inappropriate for spatial analysis or large-scale visualization. A quick visualization shows the Census tract geometries for Rio de Janeiro:

```{r}
ggplot(rj_tracts) + 
  geom_sf() + 
  theme_void()
```

For many demographic applications, users will want to identify Brazilian data that can be joined to the Census tract shapes. Although geobr does not ship with Brazilian Census data, [data tables can be downloaded from the [Instituto Brasileiro de Geografia e Estatística (IBGE) website](<https://www.ibge.gov.br/en/statistics/social/population/22836-2020-census-censo4.html?=&t=microdados>), processed using familiar tidyverse tools, and merged to the tract shapes.

### Kenya: rKenyaCensus

The [rKenyaCensus package](https://github.com/Shelmith-Kariuki/rKenyaCensus) [@kariuki2020] makes indicators from the 2019 Kenya Population and Housing Census available to R users. This package is the result of a painstaking effort by the package author [Shel Kariuki](https://shelkariuki.netlify.app/) to scrape data from PDFs containing the Census results - which is the way the original data were distributed - and convert them to R data frames. Kenyan Census tables install directly with the package and can be accessed by name. Let's take a look at table `V4_T2.30`, which contains information on religion by county in Kenya. We will assign this table to the variable `religion` for ease of reference.

```{r kenya-1}
# remotes::install_github("Shelmith-Kariuki/rKenyaCensus")
library(rKenyaCensus)
library(tidyverse)

religion <- V4_T2.30
```

```{r show-kenya-religion, echo = FALSE}
style_data(religion, n_rows = 5, caption = "religion")
```

The data are organized by county in Kenya with religious affiliations arranged by column. The first row represents data for the entirety of Kenya. Some additional data wrangling steps allow for the data to be readily plotted using familiar tooling. For example, the inclusion of the `Total` column makes calculation of proportions straightforward. In the example below, a new column `prop_islam` is computed and passed to a ggplot2 bar chart.

```{r plot-kenya, fig.height=10}
religion_prop <- religion %>%
  filter(County != "KENYA") %>%
  mutate(county_title = str_to_title(County), 
         prop_islam = Islam / Total)

ggplot(religion_prop, aes(x = prop_islam, 
                          y = reorder(county_title, prop_islam))) + 
  geom_col(fill = "navy", alpha = 0.6) + 
  theme_minimal(base_size = 12.5) + 
  scale_x_continuous(labels = scales::percent) + 
  labs(title = "Percent Muslim by County in Kenya",
       subtitle = "2019 Kenyan Census", 
       x = "",
       y = "",
       caption = "Data source: rKenyaCensus R package")
```

The visualization illustrates that most Kenyan counties have very small Muslim populations; however, a smaller number of counties have much larger Muslim populations, with percentages in some cases close to 100%. This raises related questions about the geography of these patterns, which can be mapped using additional functionality in rKenyaCensus.

The rKenyaCensus package includes a built-in county boundaries dataset to facilitate mapping of the various indicators in the Census, `KenyaCounties_SHP`. This object is of class `SpatialPolygonsDataFrame`, which will need to be converted to a simple features object with `sf::st_as_sf()`

```{r show-kenya-counties}
library(sf)

kenya_counties_sf <- st_as_sf(KenyaCounties_SHP)

ggplot(kenya_counties_sf) + 
  geom_sf() + 
  theme_void()

```

With a little additional cleaning, the religion data can be joined to the county boundaries dataset, facilitating choropleth mapping with ggplot2 and `geom_sf()`.

```{r map-kenya}
kenya_islam_map <- kenya_counties_sf %>%
  mutate(County = str_remove(County, " CITY")) %>%
  left_join(religion_prop, by = "County") 

ggplot(kenya_islam_map, aes(fill = prop_islam)) + 
  geom_sf() + 
  scale_fill_viridis_c(labels = scales::percent) + 
  theme_void() + 
  labs(fill = "% Muslim",
       title = "Percent Muslim by County in Kenya",
       subtitle = "2019 Kenyan Census",
       caption = "Data acquired with the rKenyaCensus R package")
  

tm_shape(kenya_islam_map) + 
  tm_polygons(col = "pct_islam",
              palette = "viridis", 
              style = "jenks",
              n = 7, 
              title = "% Muslim",
              alpha = 0.6)
```

The map shows how the distinct religious divides in Kenya play out geographically in the country, with proportionally few Muslim residents in the western part of Kenya and much higher percentages in the eastern part of the country.

## Other data resources

-   Many other international data resources in R exist, e.g. [nomisr](https://github.com/ropensci/nomisr) for UK data and [afrimapr](https://afrimapr.github.io/afrimapr.website/) for Africa-wide datasets

-   The [IPUMS International project](https://international.ipums.org/international/) has microdata for over 100 countries; use IPUMS data with the [ipumsr R package](https://github.com/mnpopcenter/ipumsr)

------------------------------------------------------------------------

## Part 3 exercises

-   Choose a country from the examples above and explore further. Try making a map or a chart for a new variable for a country of your choice!
